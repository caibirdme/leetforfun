## 题解

由于这道题目前不支持Golang，因此就用C来实现了。

### 暴力
直接先复制主链表，不管random，这个很简单。再用hash表存老节点和新节点的映射关系`hash[老地址]=新地址`，然后再一遍枚举来处理random。
这种方法需要使用hash，hash查找是O(1)，但是如果要考虑hash碰撞和reshashing，实现起来还是比较麻烦的。当然这道题存的是地址，想要碰撞成O(n)，几乎不可能构造出那样的数据，所以不考虑rehashing，直接开一个比较大的数组即可。
这种解法算是利用hash表完成了空间换时间

### 巧妙的办法
看了网上的提示，发现一种非常巧妙的方式。直接把新节点插到对应的老节点后面，这样一个好处是，老链表某个节点的random指向的节点，它后面紧跟的就是新节点random应该指向的节点。
所以一次遍历把链表从`old_1->old_2->...->old_n`变成`old_1->new_1->old_2->new_2->...old_n->new_n`。紧接着一次遍历，就可以把random域也copy了。最后需要一次遍历把新链表和老链表剥离。

需要注意的细节：由于Go写多了，忘了C里面新开辟的内存需要手动置NULL，不然里面会是奇怪的值。