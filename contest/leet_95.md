### Contest 95

### 链表的中间节点
[原题链接](https://leetcode-cn.com/contest/weekly-contest-95/problems/middle-of-the-linked-list/)
#### 题目大意
给定一个链表，返回链表的中间节点。如果节点数是偶数，返回靠后的那一个节点
比如：
* 3->5->7->6->9  返回7
* 3->4->5->6 返回5

#### 题解
难度：1颗星

这道题最容易想到的就是：
1. 遍历一次链表，得到其长度K
2. 得到长度K后可以算出哪个是中点，再遍历一次到那个节点即可

那么，有没有`看起来`更好一点的办法呢？

可以假设有两个小朋友A和B，都站在链表的头部，他们要一起遍历这个链表。假设A一次前进两个节点，B一次只能前进一个节点。那当A走到链表尽头时，B刚好就走到链表中间。[AC代码](https://github.com/caibirdme/leetforfun/blob/master/leetcode/leet_876/source.go)就是采用这种方法。
但是这种方法是不是就快呢？第一种方法是O(n)+O(n/2)，第二种方法虽然看起来是O(n)，但实际上循环体内部进行了两次遍历，看起来遍历的量还是一样的啊？恩，这是一个好问题（有空再想想）。参见CSAPP上的循环展开，然而，是不是真的会快还是得实际测试，并且需要到汇编层面去看这种展开能否利用上CPU的流水线。如果能用上，那就牛逼了。

### 石子游戏
[原题链接](https://leetcode-cn.com/contest/weekly-contest-95/problems/stone-game/)
#### 题目大意
有一个数组a[i]，A和B每次能从数组的头或者尾取一个数，最后谁的总数大谁赢。如果A先取，问A有没有必胜的策略。（保证数组有偶数个元素，总和是奇数）

#### 题解
##### 动态规划
先计算出a[i]的前项和sum[i]，即sum[i] = a[0]+a[1]+...a[i-1]
设dp(i,j)表示：在面对数组a[i..j]时，如果某个人先取，最大能取得的总和
如果A有必胜的策略，那么dp(1,n) > sum[n]/2。

那怎么来求dp(i,j)呢？对于a[i..j]，假设A先取，他有两种选择：
* 如果A取a[i]，那么剩下的数组就变成了a[i+1..j]，此时该B取了。B也不笨呐，B也会用最佳的策略来取，所以B在a[i+1..j]中能取到的最大值是dp(i+1,j)。设a[i+1..j]的总和是t，想一想`t-dp(i+1,j)`代表什么。t是a[i+1..j]的总和，dp(i+1,j)是先取数的那个选手所能取到的总和，显然`t-dp(i+1,j)`就是另一个人能取到的总和了。回过头来看，对于a[i..j]，Aq取a[i],B在剩下a[i+1..j]中取的最大总和是dp(i+1,j)，因此A实际能取到的值是`a[i]+t-dp(i+1,j)`
* 如果A去a[j]，那么剩下的数组就成了a[i..j-1]，同样的，设a[i..j-1]的和是t2，这时A能取到的最大值就是`a[j]+t2-dp(i,j-1)`

综上, `dp(i,j) = Max{a[i]+t-dp(i+1,j), a[j]+t2-dp(i,j-1)}`

因此很明显就是一个记忆化搜索，[AC代码](https://github.com/caibirdme/leetforfun/blob/master/leetcode/leet_877/source.go)

##### 数学归纳法
在完成动态规划的代码之后，我尝试写一些测试用例。但是写着写着我发现，我竟然构造不出A先取但结果是false的case，这让我产生了一些想法。于是试着做一下数学归纳：

* 假设只有两个数 a,b，A先取，显然他必胜，哪个大取哪个嘛
* 如果有4个数 a,b,c,d：
    * 假设A先取a, 不论B怎么取，A一定能取到c
    * 假设A先取d, 不论B怎么取，A一定能取到b

也就是说如果A先取，他一定可以要么取a,c要么取b,d。如果a+c>b+d，A就取a,c，否则他就取b,d。所以对于N等于4的case，先手一样是必胜

* 当有6个数 a,b,c,d,e,f，A一定能取到a,c,e或者b,d,f，如果a+c+e>b+d+f，那么就取a,c,e否则取b,d,f
* 当有N=2*n时，a[1...2n]
    * 如果A先取a[1]，他一定能取到a[1],a[3],a[5],... 即所有的奇数项
    * 如果A先取a[2n]，他一定能取到所有偶数项: a[2],a[4],...a[2n]

所以如果奇数项和大于偶数项和，那么A就取奇数项，否则取偶数项，因此A也是必胜的。

这里你可能有个疑惑点，凭什么说A先取a[1]，就一定能取到所有奇数项？
举个例子，假设A取a[1]，如果B取a[2]，那么A就可以取到a[3]。如果B取a[2n]，那么A可以取a[2n-1]。A始终可以取到奇数项。
同理，A先取a[2n]，如果B取a[1]，A就可以取a[2]，如果B取a[2n-1]，A就可以取a[2n-2]，A始终能取到偶数项。

因此，先手一定有必胜的策略。

所以最简单的，这道题可以直接：
```
return true
```

### 第N个神奇数字
[原题链接](https://leetcode-cn.com/contest/weekly-contest-95/problems/nth-magical-number/)

#### 题目大意
如果一个数能被A`或者`被B整除，这个数就是神奇数。给定A B，求第i小的神奇数

##### 计算+模拟
首先求出A和B的最小公倍数lcm(least common multiple)。lcm(A,B) = A*B/gcd(A,B)。 gcd(A,B)是A B的最大公约数。
我们用p表示lcm(a,b)，可以很容易发现，`a,2a,3a,4a ... (p/a)*a`都是神奇数；同样的`b,2b,...(p/b)*b`也是神奇数。所以从0到p，一共有`t=p/a + p/b - 1`个神奇数。在0到p中，除了p以外，`x*a`和`y*b`可能相等吗？——不可能，如果`x*a == y*b`，那p就不是a,b的最小公倍数了。p 2p 3p ... tp，每增加p，就增加了t个神奇数。由于求第N小的，所以`q=N/t*t*p`就是离第N小的神奇数最近的那个AB的公倍数，q是第N/t*t个神奇数。剩下的就枚举一下即可找到。
通过计算最大公约数，最大限度的减少枚举量。不知道还有没有更好的解法，没看…
[AC代码](https://github.com/caibirdme/leetforfun/blob/master/leetcode/leet_878/source.go)

### 盈利计划
[原题链接](https://leetcode-cn.com/contest/weekly-contest-95/problems/profitable-schemes/)

#### 题目大意
有G个人，有m个活动，每个活动需要group[i]个人参与，并且获得profit[i]的利润。问一个有多少种方法，使得总利润不少于P。

#### DP
仔细一看，这道题其实就是最基础的[01背包问题](https://baike.baidu.com/item/01%E8%83%8C%E5%8C%85/4301245?fr=aladdin)。G其实就是背包的容量，每个活动group[i]就是物品i的体积，profit[i]就是把物品i装入背包得到的价值。最后求解的就是总价值不少于P，一共有多少种装法。

设f(i,j,k)表示前i个物品，容量j，总价值k，一共有多少种装法。
* 如果第i个物品不装，f(i,j,k) = f(i-1,j,k)
* 如果第一个物品装，f(i,j,k) = f(i-1,j-group[i], k-profit[i])

由于我们求大于等于P一共有多少种装法，因此我们要枚举所有`f[n][j][k] (j∈[1,G], k>=P)`，把这些值累加起来。

对于01背包，有个非常常用且简单的优化空间的方法，就是倒序枚举，这个自己可以在网上搜一下，详见[AC代码](https://github.com/caibirdme/leetforfun/blob/master/leetcode/leet_879/source.go)


### 总结
这套题还是没有涉及太多的算法，主要都是靠动脑筋。石子游戏比较好，挺考验思维的。最后一题需要对DP模型比较敏感，能举一反三。这倒不是说去背题，而是说一定要把某一种类型的题吃透，之后的题会无限的多，你不可能每道题都做过，它们必然派生自某类题目。如果你吃透了那类题目的解法，那你就能很快想到解题策略。